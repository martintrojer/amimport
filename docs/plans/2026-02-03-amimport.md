# Implementation Plan: AMImport (macOS Swift App)

**Date:** 2026-02-03
**Design Doc:** User request in chat (import file -> match Apple Music library -> resolve misses -> export to playlist or enqueue; CSV first)
**Estimated Tasks:** 23

## Overview
Build a native macOS SwiftUI app (`AMImport`) with a format-extensible import pipeline (CSV first), that matches imported songs against the userâ€™s Apple Music library using configurable strategies, lets the user manually resolve misses, and exports resolved tracks to either a new Music playlist or the current queue.

## Tasks

### Task 1: Create project skeleton
**File:** `AMImport.xcodeproj` + `AMImport/App/AMImportApp.swift`
**Time:** ~5 minutes

**Steps:**
1. Create a new macOS App in Xcode named `AMImport` using SwiftUI + Swift.
2. Add folders: `App`, `Domain`, `Services`, `Features`, `Export`, `Support`.
3. Add test target folder structure: `AMImportTests/{Domain,Services,Features}`.

**Code:**
```swift
import SwiftUI

@main
struct AMImportApp: App {
    var body: some Scene {
        WindowGroup {
            RootView()
        }
    }
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `chore: bootstrap macOS SwiftUI app skeleton`

---

### Task 2: Add app permissions and capability notes
**File:** `AMImport/Support/Info.plist`
**Time:** ~3 minutes

**Steps:**
1. Add Apple Music usage description.
2. Add file import usage text for clarity.
3. Document required sandbox and capability settings in README.

**Code:**
```xml
<key>NSAppleMusicUsageDescription</key>
<string>Needed to read your Apple Music library and create playlist output.</string>
```

**Verify:**
```bash
plutil -lint AMImport/Support/Info.plist
```

**Commit:** `chore: configure Apple Music permission metadata`

---

### Task 3: Define core domain models
**File:** `AMImport/Domain/Models.swift`
**Time:** ~5 minutes

**Steps:**
1. Add `ImportTrackRow`, `LibraryTrack`, `MatchResult`, `MatchStatus`, `ExportMode`, `ImportFormat`.
2. Keep all models `Codable` where reasonable.
3. Add deterministic IDs for import rows.

**Code:**
```swift
enum MatchStatus: String, Codable {
    case unmatched, autoMatched, userMatched, skipped
}

enum ExportMode: String, CaseIterable, Codable {
    case newPlaylist
    case enqueue
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: add import and match domain models`

---

### Task 4: Red test for CSV importer plugin
**File:** `AMImportTests/Domain/CSVParserTests.swift`
**Time:** ~4 minutes

**Steps:**
1. Add failing test for header mapping with required columns.
2. Add failing test for quoted commas in title fields.
3. Add failing test for UTF-8 with BOM handling.

**Code:**
```swift
func test_parse_handlesQuotedCommas() throws {
    let csv = "title,artist\n\"One, Two\",Artist"
    let rows = try CSVParser().parse(csv)
    XCTAssertEqual(rows.first?.title, "One, Two")
}
```

**Verify:**
```bash
xcodebuild test -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS'
```

**Commit:** `test: add failing csv parser behavior tests`

---

### Task 5: Implement CSV importer plugin (green)
**File:** `AMImport/Services/Importers/CSVImporter.swift`
**Time:** ~5 minutes

**Steps:**
1. Implement CSV parser using `SwiftCSV` or a small robust parser.
2. Map canonical columns: `title`, `artist`, optional `album`, `duration`, `isrc`.
3. Return row-level parse warnings instead of crashing.
4. Conform to a shared import parser protocol to support future formats.

**Code:**
```swift
protocol ImportParsing {
    func parse(_ raw: String) throws -> [ImportTrackRow]
}
```

**Verify:**
```bash
xcodebuild test -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS'
```

**Commit:** `feat: implement resilient csv parsing service`

---

### Task 6: Add normalization utilities (red)
**File:** `AMImportTests/Domain/TrackNormalizerTests.swift`
**Time:** ~4 minutes

**Steps:**
1. Add failing tests for punctuation stripping.
2. Add failing tests for case folding and whitespace collapsing.
3. Add failing tests for featuring-artist suffix cleanup.

**Code:**
```swift
XCTAssertEqual(TrackNormalizer.normalize("  HELLO (feat. X)  "), "hello")
```

**Verify:**
```bash
xcodebuild test -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS'
```

**Commit:** `test: add failing track normalization tests`

---

### Task 7: Implement normalization + score engine (green)
**File:** `AMImport/Domain/MatchScoring.swift`
**Time:** ~5 minutes

**Steps:**
1. Implement weighted scoring for title/artist/album/duration.
2. Add thresholds for exact and fuzzy strategies.
3. Return explanation strings for UI transparency.

**Code:**
```swift
struct ScoreWeights {
    let title: Double
    let artist: Double
    let album: Double
    let duration: Double
}
```

**Verify:**
```bash
xcodebuild test -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS'
```

**Commit:** `feat: add weighted match scoring and explanations`

---

### Task 8: Add matching strategy configuration
**File:** `AMImport/Domain/MatchingOptions.swift`
**Time:** ~4 minutes

**Steps:**
1. Add enum for `exact`, `normalizedExact`, `fuzzy`.
2. Add app-level defaults and per-run override struct.
3. Add minimum-score and candidate-limit settings.

**Code:**
```swift
enum MatchingStrategy: String, CaseIterable, Codable {
    case exact
    case normalizedExact
    case fuzzy
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: add configurable matching strategy options`

---

### Task 9: Red test for Apple Music authorization service
**File:** `AMImportTests/Services/MusicAuthorizationServiceTests.swift`
**Time:** ~4 minutes

**Steps:**
1. Add protocol-based test doubles for auth status.
2. Add failing tests for denied/restricted/notDetermined paths.
3. Assert user-facing error messages are stable.

**Code:**
```swift
XCTAssertEqual(viewModel.permissionState, .denied)
```

**Verify:**
```bash
xcodebuild test -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS'
```

**Commit:** `test: add failing music authorization tests`

---

### Task 10: Implement Music authorization service (green)
**File:** `AMImport/Services/MusicAuthorizationService.swift`
**Time:** ~5 minutes

**Steps:**
1. Wrap `MusicAuthorization.request()` behind protocol.
2. Expose current status and request method.
3. Map framework errors to domain errors.

**Code:**
```swift
protocol MusicAuthorizing {
    func currentStatus() -> MusicAuthorization.Status
    func request() async -> MusicAuthorization.Status
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: implement Apple Music authorization wrapper`

---

### Task 11: Build library snapshot fetcher
**File:** `AMImport/Services/LibrarySnapshotService.swift`
**Time:** ~5 minutes

**Steps:**
1. Fetch songs in pages from the user library.
2. Convert to lightweight `LibraryTrack` for matching.
3. Add cancellation support and progress callback.

**Code:**
```swift
protocol LibrarySnapshotting {
    func fetchAll(progress: @escaping (Int) -> Void) async throws -> [LibraryTrack]
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: add paginated apple music library snapshot service`

---

### Task 12: Red test for matcher pipeline
**File:** `AMImportTests/Domain/MatcherPipelineTests.swift`
**Time:** ~4 minutes

**Steps:**
1. Add failing test for exact match prioritization.
2. Add failing test for fuzzy fallback when exact misses.
3. Add failing test for deterministic tie-breaking.

**Code:**
```swift
XCTAssertEqual(result.status, .autoMatched)
XCTAssertGreaterThan(result.candidates.count, 0)
```

**Verify:**
```bash
xcodebuild test -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS'
```

**Commit:** `test: add failing matcher pipeline tests`

---

### Task 13: Implement matcher pipeline (green)
**File:** `AMImport/Services/MatcherPipeline.swift`
**Time:** ~5 minutes

**Steps:**
1. Compose exact -> normalized -> fuzzy based on options.
2. Return top candidates and reason for decision.
3. Mark low-confidence as unresolved for manual action.

**Code:**
```swift
struct MatchDecision {
    let result: MatchResult
    let confidence: Double
    let rationale: String
}
```

**Verify:**
```bash
xcodebuild test -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS'
```

**Commit:** `feat: implement multi-strategy matching pipeline`

---

### Task 14: Build import session view model
**File:** `AMImport/Features/Import/ImportSessionViewModel.swift`
**Time:** ~5 minutes

**Steps:**
1. Add async flow: load CSV -> auth -> snapshot -> match.
2. Publish progress/state transitions for UI.
3. Keep run state serializable for later resume.

**Code:**
```swift
@MainActor
final class ImportSessionViewModel: ObservableObject {
    @Published var state: ImportState = .idle
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: add orchestrating import session view model`

---

### Task 15: Build import and matching options UI
**File:** `AMImport/Features/Import/ImportView.swift`
**Time:** ~5 minutes

**Steps:**
1. Add file picker with CSV-only constraints.
2. Add matching strategy controls + thresholds.
3. Show run progress and summary counts.

**Code:**
```swift
.fileImporter(
    isPresented: $showImporter,
    allowedContentTypes: [.commaSeparatedText]
) { _ in }
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: add import screen with strategy controls`

---

### Task 16: Build unresolved match resolution UI
**File:** `AMImport/Features/Resolve/ResolveMatchesView.swift`
**Time:** ~5 minutes

**Steps:**
1. Show unresolved rows in a table with candidate tracks.
2. Let user accept candidate, search manually, or skip.
3. Persist user choices back to import session state.

**Code:**
```swift
Table(unresolvedRows) {
    TableColumn("Title") { Text($0.csvTrack.title) }
    TableColumn("Artist") { Text($0.csvTrack.artist) }
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: add unresolved match review and resolution workflow`

---

### Task 17: Add manual library search service
**File:** `AMImport/Services/LibrarySearchService.swift`
**Time:** ~4 minutes

**Steps:**
1. Expose search by title + artist against library.
2. Debounce user input from resolve screen.
3. Return ranked candidates for one unresolved row.

**Code:**
```swift
protocol LibrarySearching {
    func searchLibrary(query: String, limit: Int) async throws -> [LibraryTrack]
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: add manual library search service for unresolved rows`

---

### Task 18: Define export contracts and DTOs
**File:** `AMImport/Export/ExportTypes.swift`
**Time:** ~3 minutes

**Steps:**
1. Add `ExportRequest` and `ExportResult`.
2. Include `ExportMode`, playlist name, and ordered track IDs.
3. Add per-track error reporting structure.

**Code:**
```swift
struct ExportRequest {
    let mode: ExportMode
    let playlistName: String?
    let trackIDs: [String]
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: define export request and result contracts`

---

### Task 19: Implement Music app bridge for playlist + queue
**File:** `AMImport/Export/MusicAppBridge.swift`
**Time:** ~5 minutes

**Steps:**
1. Implement AppleScript execution wrapper with structured errors.
2. Add command to create new playlist and add resolved tracks.
3. Add command to enqueue resolved tracks in current queue.

**Code:**
```swift
protocol MusicAppControlling {
    func createPlaylist(name: String, trackIDs: [String]) async throws
    func enqueue(trackIDs: [String]) async throws
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: add music app bridge for playlist creation and queueing`

---

### Task 20: Build export screen and execution flow
**File:** `AMImport/Features/Export/ExportView.swift`
**Time:** ~5 minutes

**Steps:**
1. Show export mode picker (`New Playlist` or `Enqueue`).
2. Validate playlist name when playlist mode selected.
3. Execute export and show success/failure summary.

**Code:**
```swift
Picker("Output", selection: $mode) {
    Text("New Playlist").tag(ExportMode.newPlaylist)
    Text("Enqueue Tracks").tag(ExportMode.enqueue)
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: add export ui and execution workflow`

---

### Task 21: Persist import sessions for resume support
**File:** `AMImport/Services/SessionStore.swift`
**Time:** ~4 minutes

**Steps:**
1. Save current session state to Application Support JSON.
2. Restore latest session on app launch.
3. Add migration version key for future schema changes.

**Code:**
```swift
protocol SessionStoring {
    func save(_ session: ImportSession) throws
    func loadLatest() throws -> ImportSession?
}
```

**Verify:**
```bash
xcodebuild -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS' build
```

**Commit:** `feat: persist import session state for recovery`

---

### Task 22: End-to-end happy path test with fakes
**File:** `AMImportTests/Features/ImportToExportFlowTests.swift`
**Time:** ~5 minutes

**Steps:**
1. Use fake library snapshot and fake export service.
2. Run CSV -> match -> resolve -> export pipeline in test.
3. Assert correct ordered track IDs passed to exporter.

**Code:**
```swift
XCTAssertEqual(fakeExporter.lastRequest?.trackIDs, ["id1", "id2", "id3"])
```

**Verify:**
```bash
xcodebuild test -project AMImport.xcodeproj -scheme AMImport -destination 'platform=macOS'
```

**Commit:** `test: cover end-to-end import to export workflow`

---

### Task 23: Document setup, constraints, and troubleshooting
**File:** `README.md`
**Time:** ~4 minutes

**Steps:**
1. Document import formats (CSV first) and matching strategies.
2. Document Apple Music permission flow and common failures.
3. Document output modes and limitations (playlist vs queue).

**Code:**
```markdown
## CSV Columns
- Required: title, artist
- Optional: album, duration, isrc
```

**Verify:**
```bash
rg "CSV Columns|Matching Strategies|Output Modes" README.md
```

**Commit:** `docs: add setup and usage guide for AMImport import pipeline`

---

## Progress Tracker

- [x] Task 1: Create project skeleton
- [x] Task 2: Add app permissions and capability notes
- [x] Task 3: Define core domain models
- [x] Task 4: Red test for CSV importer plugin
- [x] Task 5: Implement CSV importer plugin (green)
- [x] Task 6: Add normalization utilities (red)
- [x] Task 7: Implement normalization + score engine (green)
- [x] Task 8: Add matching strategy configuration
- [x] Task 9: Red test for Apple Music authorization service
- [x] Task 10: Implement Music authorization service (green)
- [x] Task 11: Build library snapshot fetcher
- [x] Task 12: Red test for matcher pipeline
- [x] Task 13: Implement matcher pipeline (green)
- [x] Task 14: Build import session view model
- [x] Task 15: Build import and matching options UI
- [ ] Task 16: Build unresolved match resolution UI
- [ ] Task 17: Add manual library search service
- [ ] Task 18: Define export contracts and DTOs
- [ ] Task 19: Implement Music app bridge for playlist + queue
- [ ] Task 20: Build export screen and execution flow
- [ ] Task 21: Persist import sessions for resume support
- [ ] Task 22: End-to-end happy path test with fakes
- [ ] Task 23: Document setup, constraints, and troubleshooting

## Notes
- This plan assumes SwiftUI for UI and MusicKit for library read access.
- Import architecture is plugin-oriented: CSV is first, future formats can implement the same parser contract.
- Playlist creation / queue manipulation is planned via a dedicated Music app bridge to avoid API lock-in.
- If MusicKit playlist write APIs fully satisfy requirements in testing, replace the bridge implementation with MusicKit-backed export.
- Execution note (2026-02-03): Bootstrapped AMImport as a Swift package app (`Sources/AMImport/...`) instead of an `.xcodeproj` because this environment does not have full Xcode configured for `xcodebuild -project`.
